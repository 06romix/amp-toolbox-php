import glob
import logging
import os
import platform
import re
import shutil
import subprocess
import sys
import tempfile
import collections

def Die(msg):
		print >> sys.stderr, msg
		sys.exit(1)


def SetupOutDir(out_dir):
	"""Sets up a clean output directory.

	Args:
		out_dir: directory name of the output directory. Must not have slashes,
			dots, etc.
	"""
	logging.info('entering ...')
	assert re.match(r'^[a-zA-Z_\-0-9]+$', out_dir), 'bad out_dir: %s' % out_dir

	if os.path.exists(out_dir):
		subprocess.check_call(['rm', '-rf', out_dir])
	os.mkdir(out_dir)
	logging.info('... done')


def GenValidatorPb2Py(out_dir):
	"""Calls the proto compiler to generate validator_pb2.py.

	Args:
		out_dir: directory name of the output directory. Must not have slashes,
			dots, etc.
	"""
	logging.info('entering ...')
	assert re.match(r'^[a-zA-Z_\-0-9]+$', out_dir), 'bad out_dir: %s' % out_dir

	subprocess.check_call(['protoc', 'validator.proto',
												 '--python_out=%s' % out_dir])
	open('%s/__init__.py' % out_dir, 'w').close()
	logging.info('... done')


def GenValidatorProtoascii(out_dir):
	"""Assembles the validator protoascii file from the main and extensions.

	Args:
		out_dir: directory name of the output directory. Must not have slashes,
			dots, etc.
	"""
	logging.info('entering ...')
	assert re.match(r'^[a-zA-Z_\-0-9]+$', out_dir), 'bad out_dir: %s' % out_dir

	protoascii_segments = [open('validator-main.protoascii').read()]
	extensions = glob.glob('extensions/*/0.1/validator-*.protoascii')
	# In the Github project, the extensions are located in a sibling directory
	# to the validator rather than a child directory.
	if not extensions:
		extensions = glob.glob('../extensions/*/0.1/validator-*.protoascii')
	extensions.sort()
	for extension in extensions:
		protoascii_segments.append(open(extension).read())
	f = open('%s/validator.protoascii' % out_dir, 'w')
	f.write(''.join(protoascii_segments))
	f.close()
	logging.info('... done')


def GeneratePHP(out_dir):
	"""Calls validator_gen_md to generate validator-generated.md.

	Args:
		out_dir: directory name of the output directory. Must not have slashes,
			dots, etc.
	"""
	logging.info('entering ...')
	assert re.match(r'^[a-zA-Z_\-0-9]+$', out_dir), 'bad out_dir: %s' % out_dir

	# These imports happen late, within this method because they don't necessarily
	# exist when the module starts running, and the ones that probably do
	# are checked by CheckPrereqs.
	from google.protobuf import text_format
	from del_dir import validator_pb2
	import validator_gen_md
	out = []
	allowed_tags = {}
	attr_lists = {}
	specfile='%s/validator.protoascii' % out_dir
	validator_pb2=validator_pb2
	text_format=text_format

	# Merge specfile with message buffers.
	rules = validator_pb2.ValidatorRules()
	text_format.Merge(open(specfile).read(), rules)

	# Build a dictionary of the named attribute lists that are used by multiple tags.
	for (field_desc, field_val) in rules.ListFields():
		if 'attr_lists' == field_desc.name:
			for attr_spec in field_val:
				if attr_spec.name not in attr_lists:
					attr_array = []
				else:
					attr_array = attr_lists[UnicodeEscape(attr_spec.name)]
				AddAttrs(attr_array, attr_spec.attrs)
				attr_lists[UnicodeEscape(attr_spec.name)] = attr_array

	# Build a dictionary of allowed tags and an associated list of their allowed attributes.
	for (field_desc, field_val) in rules.ListFields():
		if 'tags' == field_desc.name:
			for tag_spec in field_val:
				AddTag(allowed_tags, tag_spec, attr_lists)

	# Output the file's header
	out.append('<?php')
	out.append('/**')
	out.append(' * Generated by %s - do not edit.' %
						 os.path.basename(__file__))
	out.append(' *')
	out.append(' * This is a list of HTML tags and attributes that are allowed by the')
	out.append(' * AMP specification. Note that the tags have been converted to lowercase.')
	out.append(' *')
	out.append(' * Note: "$REFERENCE_POINT" is a special tag_name value.')
	out.append(' * Reference points are partial tag specs which don\'t have a defined')
	out.append(' * tag_name.')
	out.append(' */')

	# Output the version of the spec file and matching validator version
	out.append('')
	if rules.HasField('spec_file_revision'):
		out.append('$spec_file_revision = %d;' % rules.spec_file_revision)
	if rules.HasField('min_validator_revision_required'):
		out.append('$minimum_validator_revision_required = %d;' %
							 rules.min_validator_revision_required)

  # Output the allowed tags dictionary along with each tag's allowed attributes
	out.append('')
	out.append('$allowed_tags = array(')
	sorted_tags = sorted(allowed_tags.items())
	for (tag, attributes) in collections.OrderedDict(sorted_tags).iteritems():
		out.append('\t\'%s\' => array(' % tag.lower())
		for attribute in attributes:
			out.append('\t\t\'%s\' => true,' % attribute.lower())
		out.append('\t),')
	out.append(');')

	# Output the globally allowed attribute list.
	out.append('')
	out.append('$globally_allowed_attrs = array(')
	sorted_global_attrs = sorted(attr_lists['$GLOBAL_ATTRS'])
	for global_attr in sorted_global_attrs:
		out.append('\t\'%s\' => true,' % global_attr.lower())
	out.append(');')

	# Output the footer.
	out.append('')
	out.append('?>')
	out.append('')

	# Actually write the file to disk.
	f = open('%s/amp-allowed-tags-generated.php' % out_dir, 'w')
	f.write('\n'.join(out))
	f.close()
	logging.info('... done')
	

def AddTag(tag_dict, tag_spec, attr_lists):
	if tag_spec.tag_name:
		if tag_spec.tag_name not in tag_dict:
			attr_array = []
		else:
			attr_array = tag_dict[UnicodeEscape(tag_spec.tag_name)]
		AddAttrs(attr_array, tag_spec.attrs)

	# Now add attributes from any attribute lists tp this tag.
	for (tag_field_desc, tag_field_val) in tag_spec.ListFields():
		if 'attr_lists' == tag_field_desc.name:
			for attr_list in tag_field_val:
				attr_array = list(set(attr_array)|set(attr_lists[UnicodeEscape(attr_list)]))

	tag_dict[UnicodeEscape(tag_spec.tag_name)] = attr_array


def AddAttrs(attr_array, attrs):
	for attr_spec in attrs:
		if attr_spec.name not in attr_array:
			attr_array.append(UnicodeEscape(attr_spec.name))
		if attr_spec.alternative_names:
			for alternative_name in attr_spec.alternative_names:
				if attr_spec.alternative_names not in attr_array:
					attr_array.append(UnicodeEscape(alternative_name))


def UnicodeEscape(string):
	"""Helper function which escapes unicode characters.

	Args:
		string: A string which may contain unicode characters.
	Returns:
		An escaped string.
	"""
	return ('' + string).encode('unicode-escape')


def Main():
	"""The main method, which executes all build steps and runs the tests."""
	logging.basicConfig(
			format='[[%(filename)s %(funcName)s]] - %(message)s', level=logging.INFO)
	SetupOutDir(out_dir='amp_wp')
	GenValidatorProtoascii(out_dir='amp_wp')
	GenValidatorPb2Py(out_dir='amp_wp')
	GenValidatorProtoascii(out_dir='amp_wp')
	GeneratePHP(out_dir='amp_wp')

if __name__ == '__main__':
	Main()
